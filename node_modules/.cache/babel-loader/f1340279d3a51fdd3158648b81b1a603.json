{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.startsBefore = startsBefore;\nexports.positionFromDate = positionFromDate;\nexports.default = getStyledEvents;\n\nvar _accessors = require('./accessors');\n\nvar _dates = require('./dates');\n\nvar _dates2 = _interopRequireDefault(_dates);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction startsBefore(date, min) {\n  return _dates2.default.lt(_dates2.default.merge(min, date), min, 'minutes');\n}\n\nfunction positionFromDate(date, min, total) {\n  if (startsBefore(date, min)) return 0;\n\n  var diff = _dates2.default.diff(min, _dates2.default.merge(min, date), 'minutes');\n\n  return Math.min(diff, total);\n}\n/**\n * Events will be sorted primarily according to earliest start time.\n * If two events start at the same time, the one with the longest duration will\n * be placed first.\n */\n\n\nvar sort = function sort(events, _ref) {\n  var startAccessor = _ref.startAccessor,\n      endAccessor = _ref.endAccessor;\n  return events.sort(function (a, b) {\n    var startA = +(0, _accessors.accessor)(a, startAccessor);\n    var startB = +(0, _accessors.accessor)(b, startAccessor);\n\n    if (startA === startB) {\n      return +(0, _accessors.accessor)(b, endAccessor) - +(0, _accessors.accessor)(a, endAccessor);\n    }\n\n    return startA - startB;\n  });\n};\n\nvar getSlot = function getSlot(event, accessor, min, totalMin) {\n  return event && positionFromDate((0, _accessors.accessor)(event, accessor), min, totalMin);\n};\n/**\n * Two events are considered siblings if the difference between their\n * start time is less than (step*timeslots) hour.\n */\n\n\nvar isSibling = function isSibling(idx1, idx2, _ref2) {\n  var events = _ref2.events,\n      startAccessor = _ref2.startAccessor,\n      endAccessor = _ref2.endAccessor,\n      min = _ref2.min,\n      totalMin = _ref2.totalMin,\n      step = _ref2.step,\n      timeslots = _ref2.timeslots;\n  var event1 = events[idx1];\n  var event2 = events[idx2];\n  if (!event1 || !event2) return false;\n  var start1 = getSlot(event1, startAccessor, min, totalMin);\n  var start2 = getSlot(event2, startAccessor, min, totalMin);\n  var end1 = getSlot(event1, endAccessor, min, totalMin);\n  return Math.abs(start1 - start2) < step * timeslots && start2 < end1;\n};\n/**\n * An event is considered a child of another event if its start time is\n * more than (step*timeslots) hour later than the other event's start time,\n * but before its end time.\n */\n\n\nvar isChild = function isChild(parentIdx, childIdx, _ref3) {\n  var events = _ref3.events,\n      startAccessor = _ref3.startAccessor,\n      endAccessor = _ref3.endAccessor,\n      min = _ref3.min,\n      totalMin = _ref3.totalMin,\n      step = _ref3.step,\n      timeslots = _ref3.timeslots;\n  if (isSibling(parentIdx, childIdx, {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  })) return false;\n  var parentEnd = getSlot(events[parentIdx], endAccessor, min, totalMin);\n  var childStart = getSlot(events[childIdx], startAccessor, min, totalMin);\n  return parentEnd > childStart;\n};\n/**\n * Given an event index, siblings directly following it will be found and\n * returned as an array of indexes.\n */\n\n\nvar getSiblings = function getSiblings(idx, _ref4) {\n  var events = _ref4.events,\n      startAccessor = _ref4.startAccessor,\n      endAccessor = _ref4.endAccessor,\n      min = _ref4.min,\n      totalMin = _ref4.totalMin,\n      step = _ref4.step,\n      timeslots = _ref4.timeslots;\n  var nextIdx = idx;\n  var siblings = [];\n\n  while (isSibling(idx, ++nextIdx, {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  })) {\n    siblings.push(nextIdx);\n  }\n\n  return siblings;\n};\n/**\n * Given an event index, and a start search position, all child events to that\n * event will be found and placed into groups of siblings.\n * The return value is an array of child group arrays, as well as the largest\n * size of the child groups.\n */\n\n\nvar getChildGroups = function getChildGroups(idx, nextIdx, _ref5) {\n  var events = _ref5.events,\n      startAccessor = _ref5.startAccessor,\n      endAccessor = _ref5.endAccessor,\n      min = _ref5.min,\n      totalMin = _ref5.totalMin,\n      step = _ref5.step,\n      timeslots = _ref5.timeslots;\n  var groups = [];\n  var nbrOfColumns = 0;\n\n  while (isChild(idx, nextIdx, {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  })) {\n    var childGroup = [nextIdx];\n    var siblingIdx = nextIdx;\n\n    while (isSibling(nextIdx, ++siblingIdx, {\n      events: events,\n      startAccessor: startAccessor,\n      endAccessor: endAccessor,\n      min: min,\n      totalMin: totalMin,\n      step: step,\n      timeslots: timeslots\n    })) {\n      childGroup.push(siblingIdx);\n    }\n\n    nbrOfColumns = Math.max(nbrOfColumns, childGroup.length);\n    groups.push(childGroup);\n    nextIdx = siblingIdx;\n  }\n\n  return {\n    childGroups: groups,\n    nbrOfChildColumns: nbrOfColumns\n  };\n};\n\nvar constructEvent = function constructEvent(title, start, end) {\n  return {\n    title: title,\n    start: start,\n    end: end\n  };\n};\n\nvar handleMultiDayEvents = function handleMultiDayEvents(title, start, end, current) {\n  var s = new Date(start);\n  var e = new Date(end);\n  var c = new Date(current); // use noon to compare dates to avoid DST issues\n\n  s.setHours(12, 0, 0, 0);\n  e.setHours(12, 0, 0, 0);\n  c.setHours(12, 0, 0, 0); // if current day is at the start, but spans multiple days, correct the end\n\n  if (+c === +s && c < e) {\n    return constructEvent(title, start, _dates2.default.endOf(start, 'day'));\n  } // if current day is in between start and end dates, span all day\n  else if (c > s && c < e) {\n      return constructEvent(title, current, _dates2.default.endOf(current, 'day'));\n    } // if current day is at the end of a multi day event, start at midnight to the end\n    else if (c > s && +c === +e) {\n        return constructEvent(title, current, end);\n      }\n};\n/**\n * Returns height and top offset, both in percentage, for an event at\n * the specified index.\n */\n\n\nvar getYStyles = function getYStyles(idx, _ref6) {\n  var events = _ref6.events,\n      startAccessor = _ref6.startAccessor,\n      endAccessor = _ref6.endAccessor,\n      min = _ref6.min,\n      showMultiDayTimes = _ref6.showMultiDayTimes,\n      totalMin = _ref6.totalMin,\n      step = _ref6.step;\n  var event = events[idx];\n  var startDate = (0, _accessors.accessor)(event, startAccessor); // start date\n\n  var endDate = (0, _accessors.accessor)(event, endAccessor); // end date\n\n  var currentDate = new Date(min); // min is the current date at midnight\n\n  var multiDayEvent = void 0;\n\n  if (showMultiDayTimes) {\n    multiDayEvent = handleMultiDayEvents(event.title, startDate, endDate, currentDate);\n  }\n\n  var start = getSlot(multiDayEvent || event, startAccessor, min, totalMin);\n  var end = Math.max(getSlot(multiDayEvent || event, endAccessor, min, totalMin), start + step);\n  var top = start / totalMin * 100;\n  var bottom = end / totalMin * 100;\n  var height = bottom - top;\n  return {\n    top: top,\n    height: height\n  };\n};\n/**\n * Takes an array of unsorted events, and returns a sorted array\n * containing the same events, but with an additional style property.\n * These styles will position the events similarly to Google Calendar.\n *\n * The algorithm will start by sorting the array, and then iterating over it.\n * Starting at the first event, each of its siblings and children, placed in\n * groups of siblings, will be found. Both are needed in order to calculate the\n * width of the first event. When the width is known, its siblings will be\n * given the same width, but with an incremental x-offset.\n *\n * Each group of children will be looking to move as far away from its original\n * parent as possible. A move can be made to one of the parent's siblings, if\n * that sibling is also a parent to the child group. This will make room for\n * more events.\n *\n * When a child group knows its parent, it looks at the space occupied by that\n * parent, and calculates the remaning available space and divides that among\n * each other.\n *\n * All widths and x-offsets are calculated without taking overlapping into\n * account. Overlapping is added in the end according to the OVERLAP_MULTIPLIER.\n * If that is set to 0, the events won't overlap or grow.\n *\n * When one of these rounds are finished, all events connected have been\n * traversed, so the cursor will be moved past all of them.\n */\n\n\nfunction getStyledEvents(_ref7) {\n  var unsortedEvents = _ref7.events,\n      startAccessor = _ref7.startAccessor,\n      endAccessor = _ref7.endAccessor,\n      min = _ref7.min,\n      totalMin = _ref7.totalMin,\n      showMultiDayTimes = _ref7.showMultiDayTimes,\n      step = _ref7.step,\n      timeslots = _ref7.timeslots;\n  var OVERLAP_MULTIPLIER = 0.3;\n  var events = sort(unsortedEvents, {\n    startAccessor: startAccessor,\n    endAccessor: endAccessor\n  });\n  var helperArgs = {\n    events: events,\n    startAccessor: startAccessor,\n    endAccessor: endAccessor,\n    min: min,\n    showMultiDayTimes: showMultiDayTimes,\n    totalMin: totalMin,\n    step: step,\n    timeslots: timeslots\n  };\n  var styledEvents = [];\n  var idx = 0; // One iteration will cover all connected events.\n\n  var _loop = function _loop() {\n    var siblings = getSiblings(idx, helperArgs);\n\n    var _getChildGroups = getChildGroups(idx, idx + siblings.length + 1, helperArgs),\n        childGroups = _getChildGroups.childGroups,\n        nbrOfChildColumns = _getChildGroups.nbrOfChildColumns;\n\n    var nbrOfColumns = Math.max(nbrOfChildColumns, siblings.length) + 1; // Set styles to top level events.\n\n    [idx].concat(siblings).forEach(function (eventIdx, siblingIdx) {\n      var width = 100 / nbrOfColumns;\n      var xAdjustment = width * (nbrOfColumns > 1 ? OVERLAP_MULTIPLIER : 0);\n\n      var _getYStyles = getYStyles(eventIdx, helperArgs),\n          top = _getYStyles.top,\n          height = _getYStyles.height;\n\n      styledEvents[eventIdx] = {\n        event: events[eventIdx],\n        style: {\n          top: top,\n          height: height,\n          width: width + xAdjustment,\n          xOffset: width * siblingIdx - xAdjustment\n        }\n      };\n    });\n    childGroups.forEach(function (group) {\n      var parentIdx = idx;\n      var siblingIdx = 0; // Move child group to sibling if possible, since this will makes\n      // room for more events.\n\n      while (isChild(siblings[siblingIdx], group[0], helperArgs)) {\n        parentIdx = siblings[siblingIdx];\n        siblingIdx++;\n      } // Set styles to child events.\n\n\n      group.forEach(function (eventIdx, i) {\n        var parentStyle = styledEvents[parentIdx].style;\n        var spaceOccupiedByParent = parentStyle.width + parentStyle.xOffset;\n        var columns = Math.min(group.length, nbrOfColumns);\n        var width = (100 - spaceOccupiedByParent) / columns;\n        var xAdjustment = spaceOccupiedByParent * OVERLAP_MULTIPLIER;\n\n        var _getYStyles2 = getYStyles(eventIdx, helperArgs),\n            top = _getYStyles2.top,\n            height = _getYStyles2.height;\n\n        styledEvents[eventIdx] = {\n          event: events[eventIdx],\n          style: {\n            top: top,\n            height: height,\n            width: width + xAdjustment,\n            xOffset: spaceOccupiedByParent + width * i - xAdjustment\n          }\n        };\n      });\n    }); // Move past all events we just went through\n\n    idx += 1 + siblings.length + childGroups.reduce(function (total, group) {\n      return total + group.length;\n    }, 0);\n  };\n\n  while (idx < events.length) {\n    _loop();\n  }\n\n  return styledEvents;\n}","map":null,"metadata":{},"sourceType":"script"}